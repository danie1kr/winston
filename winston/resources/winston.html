<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>winston</title>
    <link rel="stylesheet" href="./materialicons.css">
    <script type="text/javascript" src="lodash.min.js"></script>
    <script type="text/javascript" src="zepto.min.js"></script>

    <link type="text/css" rel="stylesheet" href="materialize.min.css" media="screen,projection" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="white" />
    <meta name="description" content="winston model train remote">

    <style>
        #overlay {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.5);
            padding-top: 30%;
            z-index: 500000;
            cursor: pointer;
        }

        #railway {
            position: absolute;
            min-height: 100vh;
            width: calc(100% - 600px);
            z-index: 3000;
        }

        .contextMenu {
            position: absolute;
            z-index: 5000;
            background-color: white;
            border-color: #26a69a;
            border-radius: 2px;
            border-style: solid;
            box-shadow: 0 2px 2px 0 rgba(0,0,0,0.14), 0 3px 1px -2px rgba(0,0,0,0.12), 0 1px 5px 0 rgba(0,0,0,0.2);
            padding: 8px;
        }

        #settingsToggle {
            font-size: larger;
        }

        #settingsContent {
            position: fixed;
            width: calc(100% - 600px);
            background-color: white;
            z-index: 10000;
        }

        body {
            display: flex;
            min-height: 100vh;
            flex-direction: column;
        }

        header, main, footer {
            padding-left: 300px;
            padding-right: 300px;
            width: calc(100% - 300px);
        }

        main {
            flex: 1 0 auto;
        }

        #console {
            position: absolute;
            padding-left: 10px;
            /* bottom: 30%; */
        }

        #connection {
            position: absolute;
            padding-left: 10px;
            bottom: 8%;
            /* height: 8%; */
            overflow: auto;
        }
    </style>

    <script type="text/template" id="template_turnout">
        <div class="winston-turnout row" winston-turnout-track="<%= id %>" winston-turnout-direction="<%= direction %>">
            <div class="name col s4"><%= name %></div><div class="direction col s3"><%= direction %></div>

            <div class="col s2"><a class="waves-effect waves-light btn">toggle</a></div>
        </div>
    </script>

    <script type="text/template" id="template_loco">
        <div class="winston-locomotive row" winston-loco-address="<%= address %>" winston-type="locomotive" winston-id="<%= address %>">
            <div class="row">
                <div class="name col s3"><%= name %></div>
                <div class="address col s1"><%= address %></div>
                <div class="switch col s8">
                    <i class="small material-icons">highlight</i>
                    <label>
                        Off <input type="checkbox" class="light"> <span class="lever"></span> On
                    </label>
                </div>

            </div>
            <div class="row">
                <div class="col s3">
                    <label class="speedValue"></label>
                </div>
                <div class="col s5"></div>
                <div class="col s4"><a class="waves-effect waves-light btn">stop</a></div>
            </div>
            <div class="row">
                <input class="speed" type="range" min="-100" max="100" />
            </div>
            <hr>
        </div>
    </script>


    <script type="text/template" id="template_detector_debug_loco">
        <option value="<%= id %>"><%= name %></option>
    </script>

</head>

<body>
    <div id="overlay">
        <div class="row">
            <div class="div col s8 offset-s2 valign-wrapper">
                <div class="progress">
                    <div class="indeterminate">
                    </div>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="div col s8 offset-s5 valign-wrapper">
                <a class="waves-effect waves-light btn" id="reconnect">reconnect</a>
            </div>
        </div>
    </div>

    <div id="menuTrackEdge" class="contextMenu">
        <a id="splitEdge" class="waves-effect waves-light btn cancel">split track</a>
        <a class="waves-effect waves-light btn cancel">cancel</a>
    </div>

    <div id="menuTrackNode" class="contextMenu">
        <a id="deleteTrackNode" class="waves-effect waves-light btn cancel">delete node</a>
        <a class="waves-effect waves-light btn cancel">cancel</a>
    </div>

    <div id="menuEditNode" class="contextMenu">
        <a id="pullConnectedNode" class="waves-effect waves-light btn cancel">pull connected node</a>
        <a class="waves-effect waves-light btn cancel">cancel</a>
    </div>

    <div id="menuTrackNode" class="contextMenu row">
        <div class="input-field col">
            <input placeholder="name" id="trackNodeName" type="text" class="validate">
            <label for="trackNodeName">Name</label>
        </div>
        <div class="col">
            <a class="waves-effect waves-light btn cancel">cancel</a>
        </div>
    </div>

    <div id="infoSignal" class="contextMenu">
        <div class="row>">
            <div class="col">
                <label for="infoSignalParent">Track</label>
                <p id="infoSignalParent"></p>
            </div>
            <div class="col">
                <label for="infoSignalConnection">Connection</label>
                <p id="infoSignalConnection"></p>
            </div>
        </div>
        <div class="row">
            <div class="col">
                <label for="infoSignalLights">Lights</label>
                <p id="infoSignalLights"></p>
            </div>
        </div>
    </div>

    <div id="infoDebugDetector" class="contextMenu">
    </div>

    <header>
        <div>
            winston <label id="settingsToggle">⚙</label>
            <div id="settingsContent" class="row">
                <div class="input-field col s2"><input placeholder="IP" id="ip" type="text" class="validate" value="127.0.0.1"><label for="ip">IP</label></div>
                <div class="switch col s6">
                    <div>Grid <label>hide <input id="gridView" type="checkbox"><span class="lever"></span>show</label></div>
                    <div>Layout <label>fixed <input id="layoutEdit" type="checkbox"><span class="lever"></span>edit</label></div>
                    <div>Blocks <label>view <input id="blockView" type="checkbox"><span class="lever"></span>off</label></div>
                    <div>Detector Debug <label>on <input id="detectorDebug" type="checkbox"><span class="lever"></span>off</label> 
                            <div class="input-field col s12">
                                <select id="detectorDebugLoco">
                                    <option value="" disabled selected>Choose a locomotive</option>
                                </select>
                                    <label>Detector </label>
                            </div>
                    </div>
                    <a id="saveLayout" class="waves-effect waves-light btn-small">Save Layout</a>
                    <a id="resetLayout" class="waves-effect waves-light btn-small">Reset Layout</a>
                </div>
            </div>
            <hr>
        </div>
        <div id="error"></div>

        <ul id="sideLoco" class="sidenav sidenav-fixed">
            <ul class="collapsible expandable">
                <li id="locoShedContainer" class="active">
                    <div class="collapsible-header">Locomotives</div>
                    <div class="collapsible-body"></div>
                </li>
            </ul>
        </ul>

        <ul id="sideTurnout" class="sidenav sidenav-fixed">
            <ul class="collapsible expandable">
                <li id="turnoutsContainer" class="active">
                    <div class="collapsible-header">Turnouts</div>
                    <div class="collapsible-body"></div>
                </li>
            </ul>
            <div id="console">
                <h5>Console</h5>
                <div id="messages"></div>
            </div>
            <div id="connection" class="right-align">not connected</div>
        </ul>
    </header>


    <main id="container">
        <div id="railway"></div>

    </main>
    <!--
        <footer class="page-footer">
            <div class="container">

            </div>
        </footer>
    -->
    <script type="text/javascript">
        const SocketClosed = 0;
        const SocketConnecting = 1;
        const SocketOpen = 2;

        let socketState = SocketClosed;
        let socket = null;

        const SocketReconnectTimeout = 10 * 1000;
        function connect() {
            socketState = SocketConnecting;
            socket = new WebSocket("ws://" + $("#ip").val());

            socket.onmessage = function (event) {
                parse(JSON.parse(event.data));
            }

            socket.onopen = function (event) {
                socketState = SocketOpen;
                $("#connection").html("connected");
                $("#overlay").hide();
            }

            socket.onclose = function (event) {

                if (socketState === SocketConnecting)
                    _.delay(connect, SocketReconnectTimeout);

                socketState = SocketClosed;
                $("#connection").html("not connected");
                $("#overlay").show();
            }
        }

        let railway, signals, blocks, detectors, layout, $railway, $saveLayout, $resetLayout, cy, uiEditLayout = false, allowLayoutStorage = true, allowLayoutLoading = true;

        const WinstonTypeTurnout = "turnout";
        const WinstonTypeLocomotive = "locomotive";
        const TurnoutState_A_B = 0;
        const TurnoutState_A_C = 1;
        const TurnoutState_Changing = 2;

        function turnoutDirectionLabelFromDirection(direction) {
            switch (direction) {
                case 0: return "A-B";
                case 1: return "A-C";
                default:
                    return "changing";
            }
        }

        function allowLayoutEdit() {
            return uiEditLayout === true;
        }

        function allowWinstonSubmit() {
            return uiEditLayout === false;
        }

        function winstonGet(type, id) {
            return $("[winston-type=\"" + type + "\"][winston-id=\"" + id + "\"]");
        }

        function loco(data) {
            let address = data.address;
            let $element = winstonGet(WinstonTypeLocomotive, address);

            if ($element === undefined || $element.length === 0) {
                let $locoShedContainerBody = $("#locoShedContainer>div.collapsible-body");
                let locoTemplate = _.template($("#template_loco").html());
                $element = $(locoTemplate({ address: address, name: data.name }));
                $element.find(".speed").on("change", doControlLoco);
                $element.find(".light").on("change", doControlLoco);
                $element.find(".stop").on("click", function (event) {
                    $element.find(".speed").val(0);
                    doControlLoco(event);
                });

                $locoShedContainerBody.append($element);
            }

            let $elementDetectorDebugLoco = $("#detectorDebugLoco>option[value=\"" + address + "\"]");
            if ($elementDetectorDebugLoco === undefined || $elementDetectorDebugLoco.length === 0) {
                let $detectorDebugLocoSelect = $("#detectorDebugLoco");
                let locoTemplate = _.template($("#template_detector_debug_loco").html());
                $element = $(locoTemplate({ id: address, name: data.name }));
                $detectorDebugLocoSelect.append($element);
                M.FormSelect.init(document.querySelectorAll('select'));
            }

            let locoNode = cy.$("node.locomotive[address=\"" + address + "\"]");
            if (locoNode === undefined || locoNode === 0) {
                locoNode = { group: 'nodes', data: { address: address }, classes: "locomotive" };
                cy.add(locoNode);
            }
            $element.find(".speed").val(data.forward ? data.speed : -data.speed);
            $element.find(".speedValue").html(data.value);
            $element.find(".light").prop("checked", data.light ? "checked" : undefined);
        }

        function turnoutGet(id) {
            return winstonGet(WinstonTypeTurnout, id);
        }

        function turnoutUpdate(turnout) {
            let direction = turnout.data("direction");
            let track = turnout.data("track");
            switch (direction) {
                case TurnoutState_A_B:
                    turnout.neighborhood("[connection=\"b\"]").style("visibility", "visible");
                    turnout.neighborhood("[connection=\"c\"]").style("visibility", "hidden");
                    break;
                case TurnoutState_A_C:
                    turnout.neighborhood("[connection=\"b\"]").style("visibility", "hidden");
                    turnout.neighborhood("[connection=\"c\"]").style("visibility", "visible");
                    break;
                default:
                case TurnoutState_Changing:
                    turnout.neighborhood("[connection=\"b\"]").style("visibility", "hidden");
                    turnout.neighborhood("[connection=\"c\"]").style("visibility", "hidden");
                    break;
            }

            $(".winston-turnout[winston-turnout-track=\"" + track + "\"]>.direction").html(turnoutDirectionLabelFromDirection(direction));
        }

        function turnoutState(data) {
            let id = data.id;
            let direction = data.state;

            let turnout = cy.nodes(".turnout[track=\"" + id + "\"]").data("direction", direction);
            turnoutUpdate(turnout);
        }

        function turnoutToggle(event) {
            sendTurnoutToggle(event.target.data("track"), event.target.data("direction"));
        }

        function sendTurnoutToggle(track, direction) {
            if (!allowWinstonSubmit())
                return;

            let id = track;//parseInt(track);
            cy.nodes(".turnout[track=\"" + id + "\"]").off("click");

            if (direction !== TurnoutState_Changing)
                send("doTurnoutToggle", { id: id });
        }

        function turnoutRequestStatus(track) {
            if (!allowWinstonSubmit())
                return;
            send("getTurnoutState", { id: track });
        }

        function signalRequestStatus(guarding, parentTrack) {
            if (!allowWinstonSubmit())
                return;
            send("getSignalState", { parentTrack: parentTrack, guarding: guarding });
        }

        function locoPositions(data) {
            _.each(data, loco => {
                let locoNode = cy.$("node.locomotive[address=\"" + loco.address + "\"]");
                
            });
        }

        function signalState(data) {
            let track = data.parentTrack;
            let guarding = data.guarding;
            let aspects = data.aspects;

            let colorClass = aspects & 0b00100 ? "green" : "red";

            if (aspects & 0b00001) colorClass = "black";        // Off
            else if (aspects & 0b00010) colorClass = "red";   // Halt
            else if (aspects & 0b00100) colorClass = "green";   // Go
            else if (aspects & 0b01000) colorClass = "yellow";  // ExpectHalt
            else if (aspects & 0b10000) colorClass = "turquoise";   // ExpectGo

            let signal = cy.nodes(".signal[id=\"" + track + "_signal_" + guarding + "\"]")
            //    .removeClass("black").removeClass("green").removeClass("red").removeClass("yellow").removeClass("turquoise")
            //    .addClass(colorClass)
                .data("aspects", aspects);
        }

        function doControlLoco(event) {
            let $target = $(event.target);
            let $loco = $($target.closest(".winston-locomotive"));
            let speed = parseInt($loco.find(".speed").val());

            send("doControlLoco", {
                address: parseInt($loco.attr("winston-loco-address")),
                light: $loco.find(".light").prop("checked"),
                forward: speed > 0,
                speed: speed
            });
        }

        function hideContextMenus() {
            $(".contextMenu").hide();
        }

        function click(menu, event) {
            if (!allowLayoutEdit()) {
                graphCalculateReachability(event)
                return;
            }
            else {
                hideContextMenus();

                let $contextMenu = $("#" + menu);
                if (menu === "menuTrackNode") {
                    let node = event.target;
                    let name = node.data("displayName");
                    $("#trackNodeName")
                        .val(name ? name : node.data("name"))
                        .off('change')
                        .on('change', function (e) {
                            let name = e.target.value;
                            node.data("displayName", name);
                            $("#turnoutsContainer>div.collapsible-body")
                                .find("[winston-turnout-track=\"" + node.data("track") + "\"]")
                                .find(".name")
                                .html(name);
                        });

                }

                $contextMenu
                    .css("top", event.originalEvent.clientY + 'px')
                    .css("left", (event.originalEvent.clientX + 20) + 'px')
                    .show();
            }
        }

        function signalInfo(event) {
            hideContextMenus();
            let $info = $("#infoSignal");
            let node = event.target;
            //$info.find("#infoSignalId").text(node.data("id"));
            $info.find("#infoSignalParent").text(node.data("parentTrack"));
            $info.find("#infoSignalConnection").text(node.data("guarding"));
            let lights = _.map(node.data("lights"), l => " Port: " + l.port)
            let lightsText = lights.join("<br>");
            $info.find("#infoSignalLights").html(lightsText);
            $info.css("top", event.originalEvent.clientY + 'px')
                .css("left", (event.originalEvent.clientX + 20) + 'px')
                .show();
        }

        function sendInjectDetector(locoAddress, id) {
            if (!allowWinstonSubmit())
                return;
            send("emu_dcs_inject_detector", { loco: locoAddress, id: id });
        }

        function detectorClick(event) {

            if ($("#detectorDebug").prop("checked")) {
                let loco = $("#detectorDebugLoco").val();
                let node = event.target;
                sendInjectDetector(loco, node.data("detectorId"));
            }
            else {
                hideContextMenus();
                // infoDebugDetector
                // show connection info
            }
        }

        function cytoscapeCreate() {
            return cy = cytoscape({
                container: $railway,
                layout: { name: 'preset' },
                boxSelectionEnabled: true,
                panningEnabled: true,
                style: [
                    {
                        selector: ".trackConnector",
                        style: {
                            "line-color": '#F00',
                            "width": 10
                        }
                    },
                    {
                        selector: ".internal",
                        style: {
                            "line-color": 'orange',
                            "width": 8
                        }
                    },
                    {
                        selector: ".trackNode",
                        style: {
                            "width": 20,
                            "height": 20,
                            "shape": "rectangle"
                        }
                    },
                    {
                        selector: ".trackSplitNode",
                        style: {
                            "width": 8,
                            "height": 8,
                            "shape": "rectangle"
                        }
                    },
                    {
                        selector: ".track",
                        style: {
                            "width": 8
                        }
                    },
                    {
                        selector: ".connection",
                        style: {
                            "width": 8,
                            "height": 8
                        }
                    },
                    {
                        selector: ".connector",
                        style: {
                            "width": 8,
                            "height": 8
                        }
                    },
                    {
                        selector: ".highlight",
                        style: {
                            "background-color": "orange",

                        }
                    },
                    {
                        selector: ".reachable",
                        style: {
                            "line-color": 'green',
                        }
                    },
                    {
                        selector: ".signalConnector",
                        style: {
                            "width": 1
                        }

                    },
                    {
                        selector: ".signal",
                        style: {
                            "width": 10,
                            "height": 10,
                            "shape": "octagon",
                            //"background-color": "red"
                        }

                    }/*,
                    {
                        selector: ".signal.black",
                        style: {
                            "background-color": "black"
                        }

                    },
                    {
                        selector: ".signal.green",
                        style: {
                            "background-color": "green"
                        }

                    },
                    {
                        selector: ".signal.red",
                        style: {
                            "background-color": "red"
                        }

                    },
                    {
                        selector: ".signal.yellow",
                        style: {
                            "background-color": "yellow"
                        }

                    },
                    {
                        selector: ".signal.turquoise",
                        style: {
                            "background-color": "turquoise"
                        }

                    }*/,
                    {
                        selector: "node.detector",
                        style: {
                            "width": 24,
                            "height": 24,
                            "shape": "rectangle",
                            "background-color": "red"
                        }

                    },
                    {
                        selector: "edge.detector",
                        style: {
                            "width": 1
                        }

                    },
                    {
                        selecotr: "node.locomotive",
                        style: {
                            "width": 8,
                            "height": 8,
                            "shape": "diamond"
                        }
                    },
                    {
                        selector: "node.blockColoring",
                        style: {
                            "background-color": "data(blockColor)"
                        }
                    },
                    {
                        selector: "edge.blockColoring",
                        style: {
                            "line-color": "data(blockColor)"
                        }
                    }
                ]
            }).gridGuide({
                snapToGridOnRelease: true,
                snapToGridDuringDrag: true,
                snapToGridCenter: false,
                gridSpacing: 10,
                guidelinesStyle: {
                    strokeStyle: "black",
                    horizontalDistColor: "#ff0000",
                    verticalDistColor: "green",
                    initPosAlignmentColor: "#0000ff",
                }
            }).nodeHtmlLabel([
                {
                    query: '.trackNode',
                    valign: "center",
                    halign: "center",
                    valignBox: "center",
                    halignBox: "center",
                    tpl: function (data) {
                        return '<p>' + (data.displayName ? data.displayName : data.name) + '</p>';
                    }
                },
                {
                    query: '.signal',
                    valign: "center",
                    halign: "center",
                    valignBox: "center",
                    halignBox: "center",
                    tpl: function (data) {
                        let html = "";
                        _.each(data.lights, l => {
                            let color = "black";
                            let symbol = "B";
                            
                            if (l.aspect == 0b00010) { if (l.aspect & data.aspects) { color = "red"; } symbol = "●"; }
                            if (l.aspect == 0b00100) { if (l.aspect & data.aspects) { color = "green"; } symbol = "●"; }
                            if (l.aspect == 0b01000) { if (l.aspect & data.aspects) { color = "red"; } symbol = "○"; }
                            if (l.aspect == 0b10000) { if (l.aspect & data.aspects) { color = "green"; } symbol = "○"; }

                            html += '<span style="color:' + color + ';">' + symbol + '</span>';
                        });

                        return '<p>'
                            + html
                            + '</p>';
                    }
                }]);
        }

        function cytoscapePostAdd(cy) {
            cy.on('click', '.trackSplitNode', function (event) {
                click("menuTrackNode", event);
            });
            cy.on('click', '.track', function (event) {
                click("menuTrackEdge", event);
            });
            cy.on('click', '.connection, .connector', function (event) {
                click("menuEditNode", event);
            })
            cy.on('click', '.signal', function (event) {
                signalInfo(event);
            });
            cy.on('click', 'node.detector', function (event) {
                detectorClick(event);
            });
            cy.on('unselect', '.track, .trackNode, .track, .signal, .detector', function () {
                cy.elements().removeClass("reachable");
                hideContextMenus();
            });
            cy.on('mouseover', '.turnout', function (event) {
                event.target.neighborhood(".turnoutConnection").addClass("highlight");
            });
            cy.on('mouseout', '.turnout', function (event) {
                event.target.neighborhood(".turnoutConnection").removeClass("highlight");
            });

            cy.on('mouseover', '.trackNode', function (event) {
                event.target.neighborhood(".signalConnector").show();
            });
            cy.on('mouseout', '.trackNode', function (event) {
                event.target.neighborhood(".signalConnector").hide();
            });

            cy.on('position', '.trackNode .signal', function () {
                if (!allowLayoutEdit())
                    return;
            });

            cy.on('position', '.bumper, .turnout, .rail', function (event) {
                if (!allowLayoutEdit())
                    return;
                let that = event.target;
                cy.$("node.connection[track=\"" + that.data("track") + "\"], node.trackSplitNode[track=\"" + that.data("track") + "\"]").each(function (e) {
                    if(!e.selected())
                        e.position({ x: that.position().x + e.data("relativePosition").x, y: that.position().y + e.data("relativePosition").y });
                });
            });

            cy.on('position', '.connection', function (event) {
                if (!allowLayoutEdit())
                    return;
                let that = event.target;
                let parentPosition = cy.$("node.trackNode[track=\"" + that.data("track") + "\"]").position();
                that.data("relativePosition", { x: that.position().x - parentPosition.x, y: that.position().y - parentPosition.y });

                that.neighborhood(".signal").each(function (e) {
                        if(!e.selected())
                    e.position({ x: that.position().x + e.data("relativePosition").x, y: that.position().y + e.data("relativePosition").y });
                });
            });

            cy.on('position', '.signal', function (event) {
                if (!allowLayoutEdit())
                    return;
                let that = event.target;
                let parentPosition = cy.$("node.connection." + that.data("guarding") + "[track=\"" + that.data("parentTrack") + "\"]").position();
                that.data("relativePosition", { x: that.position().x - parentPosition.x, y: that.position().y - parentPosition.y });
            });

            cy.on('click', '.turnout', turnoutToggle);

            cy.nodes().ungrabify();

            let $turnoutsContainerBody = $("#turnoutsContainer>div.collapsible-body");
            $turnoutsContainerBody.empty();
            cy.$(".turnout").each(function (turnout) {

                let turnoutTemplate = _.template($("#template_turnout").html());
                let $turnout = $(turnoutTemplate({ id: turnout.data("track"), name: turnout.data("displayName") ? turnout.data("displayName") : turnout.data("name"), direction: turnout.data("direction") }));
                $turnout.on('click', function (event) {
                    let $target = $(event.target);
                    let $closest = $($target.closest(".winston-turnout"));
                    sendTurnoutToggle($closest.attr("winston-turnout-track"), $closest.attr("winston-turnout-direction"));
                });
                $turnoutsContainerBody.append($turnout);
                turnoutRequestStatus(turnout.data("track"));
            });
            cy.$(".signal").each(function (signal) {
                signalRequestStatus(signal.data("guarding"), signal.data("parentTrack"));
            });

            let URLsp = new URLSearchParams(window.location.search);
            $("#layoutEdit").prop("checked", URLsp.has("layoutEdit") ? "checked" : null)
                .trigger("change");
            $("#blockView").prop("checked", URLsp.has("blockView") ? "checked" : null)
                .trigger("change");
            $("#detectorDebug").prop("checked", URLsp.has("detectorDebug") ? "checked" : null)
                .trigger("change");

            return cy;
        }

        let layoutString = "";
        let layoutStringSizeReceived = 0;
        function updateRailwayLayout(data) {
            let offset = data.offset;
            let fullSize = data.fullSize;
            let partialLayout = data.layout;

            layoutStringSizeReceived += partialLayout.length;

            if (layoutString.length < fullSize)
                layoutString = new Array(fullSize + 1).join(" ");

            layoutString = [layoutString.slice(0, offset), partialLayout, layoutString.slice(offset + partialLayout.length)].join('');

            if (layoutStringSizeReceived === fullSize) {
                layout = JSON.parse(layoutString);
                if (checkGraphIsomorphism(railway, layout)) {
                    cy.destroy();
                    cy = cytoscapeCreate();
                    cy.add(layout.cy);
                    cy = cytoscapeUpdateSignals(cy, signals);
                    cy = cytoscapeUpdateBlocks(cy, blocks);
                    cy = cytoscapeUpdateDetectors(cy, detectors);
                    cy = cytoscapePostAdd(cy);

                    cy.viewport({ zoom: layout.viewport.zoom, pan: layout.viewport.pan });
                }
                else {
                    alert("railway and layout mismatch!");
                    /*    cy.destroy();
                        cy = cytoscapeCreate();
                        cy.add(layout.cy);
                        cy = cytoscapeUpdateRailway(cy, data.tracks);
                        cy = cytoscapeUpdateSignals(cy, signals);
                        cy = cytoscapeUpdateBlocks(cy, blocks);
                        cy = cytoscapePostAdd(cy);*/

                    cy.viewport({ zoom: layout.viewport.zoom, pan: layout.viewport.pan });
                }
            }
        }

        function storeRailwayLayout() {
            let layout =
            {
                viewport: { zoom: cy.zoom(), pan: cy.pan() },
                cy: cy.$().jsons()
            }

            let payload = JSON.stringify(layout);
            let offset = 0;
            let size = 0;
            let chunkSize = 32000;
            for (let i = 0; i < payload.length; i += chunkSize)
                send("storeRailwayLayout", { layout: payload.substring(i, Math.min(i + chunkSize, payload.length)), offset: i, fullSize: payload.length });

        }

        function checkGraphIsomorphism(railway, layout) {
            if (!layout || layout.length === 0 || !layout.cy)
                return false;

            let cyLayout = cytoscape();
            cyLayout.add(layout.cy);

            let success = true;
            _.each(railway, function (track, i) {

                let layoutTrack = cyLayout.$(".trackNode[name=\"" + track.name + "\"]");

                let localSuccess = layoutTrack !== undefined && layoutTrack.length > 0 &&
                    layoutTrack.data("connections").a === track.a &&
                    layoutTrack.data("connections").b === track.b &&
                    layoutTrack.data("connections").c === track.c;

                if (!localSuccess) {
                    console.log(track.name, layoutTrack, track, i);
                }

                success &&= localSuccess;
            });

            return success;
        }

        function graphCalculateReachability(event) {
            cy.elements().removeClass("reachable");
            function traverse($edge) {
                if ($edge.hidden())
                    return;

                $edge.addClass("reachable");
                let $nodes = $edge.connectedNodes();
                _.each($nodes, function ($node) {

                    if ($node.hasClass("reachable"))
                        return;

                    let $edges = $node.connectedEdges().filter(function (e) { return e !== $edge; });

                    if ($node.hasClass("turnout") || $node.hasClass("turnoutConnection")) {
                        $node.addClass("reachable");
                        _.each($edges, traverse);
                    }
                    else if ($node.hasClass("bumper")) {
                        // we came here somehow (via a), so there is nothing else to do
                        $node.addClass("reachable");
                    }
                    else //rail
                    {
                        $node.addClass("reachable");
                        _.each($edges, traverse);
                    }
                });
            }
            let $edge = cy.$(event.target);
            traverse($edge);
        }

        function cytoscapeUpdateRailway(cy, railway) {
            _.each(railway, function (track, i) {
                let layoutTrack = cy.$(".trackNode[name=\"" + track.name + "\"]");

                // added track in railway list
                if (layoutTrack === undefined) {
                    addTrackToLayout(cy.nodes(), cy.edges(), railway.tracks, track, i);
                }

                let localSuccess = layoutTrack !== undefined && layoutTrack.length > 0 &&
                    layoutTrack.data("connections").a === track.a &&
                    layoutTrack.data("connections").b === track.b &&
                    layoutTrack.data("connections").c === track.c;

                if (!localSuccess) {
                    console.log(layoutTrack.data("name"), track, i);
                }
            });
            return cy;
        }

        function cytoscapeUpdateSignals(cy, signals) {
            let nodes = [];
            let edges = [];

            cy.$("node.signal").addClass("unverified");

            _.each(signals, function (signal, i) {
                let track = signal.parentTrack;
                let guarding = signal.guarding;
                let parentNode = guarding === "deadend"
                    ? "node.trackNode.bumper[track=\"" + track + "\"]"
                    : "node.connection." + guarding + "[track=\"" + track + "\"]";

                let parentPosition = cy.$(parentNode).position();
                let edgeTarget = guarding === "deadend"
                    ? cy.$(parentNode).id()
                    : track + "_" + guarding;

                let existing = cy.$("node.signal[parentTrack=\"" + track + "\"][guarding=\"" + guarding + "\"]");
                if (existing.length > 0) {
                    existing.removeClass("unverified");
                    existing.data("lights", signal.lights);
                }
                else {
                    let lights = signal.lights;
                    nodes.push({ group: 'nodes', data: { id: track + "_signal_" + guarding, guarding: guarding, parentTrack: track, lights: lights, relativePosition: { x: 0, y: 20 } }, position: { x: parentPosition.x, y: parentPosition.y + 20 }, classes: "signal" });
                    edges.push({ group: 'edges', data: { source: track + "_signal_" + guarding, target: edgeTarget }, classes: "signalConnector" });
                }
            });

            let unverified = cy.$(".unverified");
            console.log("removing " + unverified.length + " signals");
            unverified.remove();

            cy.add(nodes);
            cy.add(edges);

            return cy;
        }

        function cytoscapeUpdateBlocks(cy, blocks) {
            _.each(blocks, function (block, i) {
                _.each(block.tracks, function (track, j) {
                    cy.$("[track=\"" + track + "\"]").forEach(function (ele, i, eles) {
                        ele.data("block", block.address);
                        ele.data("blockColor", "#red");
                    });
                });
            });

            return cy;
        }


        function cytoscapeUpdateDetectors(cy, detectors) {
            let nodes = [];
            let edges = [];

            cy.$("node.detector").addClass("unverified");

            _.each(detectors, function (detector, i) {
                let id = detector.id;
                let track = detector.track;
                let connection = detector.connection;

                let parentPosition = cy.$("node.connection." + connection + "[track=\"" + track + "\"]").position();

                let existing = cy.$("node.detector[parentTrack=\"" + track + "\"][connection=\"" + connection + "\"]");
                if (existing.length > 0) {
                    existing.removeClass("unverified");
                }
                else {
                    nodes.push({ group: 'nodes', data: { detectorId: id, id: track + "_detector_" + connection, connection: connection, parentTrack: track, relativePosition: { x: 20, y: 0 } }, position: { x: parentPosition.x + 20, y: parentPosition.y }, classes: "detector" });
                    edges.push({ group: 'edges', data: { source: track + "_detector_" + connection, target: track + "_" + connection }, classes: "detector" });
                }
            });

            let unverified = cy.$(".unverified");
            console.log("removing " + unverified.length + " detectors");
            unverified.remove();

            cy.add(nodes);
            cy.add(edges);

            return cy;
        }

        function addTrackToLayout(edges, nodes, tracks, track, xPos) {
            function connect(that, otherTrackName, connectionName) {
                let other = _.find(tracks, t => t.name === otherTrackName);

                let thatNode = _.find(nodes, function (n) { return n.data.track === that; });
                let otherNode = _.find(nodes, function (n) { return n.data.track === otherTrackName; });

                if (thatNode === undefined || otherNode === undefined)
                    return;

                let from = that + "_" + connectionName;//(thatNode.data.type !== "bumper"/* && connectionName !== "a"*/ ? connectionName : "");

                function connectToOther(otherConnectionName) {
                    if (other[otherConnectionName] === that) {
                        let to = otherTrackName + "_" + otherConnectionName; // (otherNode.data.direction !== undefined /*&& otherConnectionName !== "a" */ ? otherConnectionName : "");
                        let id = from + "-" + to;
                        /* one edge between other-A and B-that
                        edges.push({ group: 'edges', data: { id: id, name: id, source: from, target: to }, classes: "" });
                        */

                        // another connector node between other-A and B-that
                        nodes.push({ group: 'nodes', data: { id: id}, classes: "connector" });
                        edges.push({ group: 'edges', data: { source: from, target: id, track: that}, classes: "track" });
                        edges.push({ group: 'edges', data: { source: to, target: id, track: otherTrackName}, classes: "track" });
                    }
                }

                connectToOther("a");
                connectToOther("b");
                connectToOther("c");
            }

            let a = track.a;
            let b = track.b;
            let c = track.c;
            let id = track.name;

            let type = 0;
            if (c !== undefined)
                type = 2;
            else if (b !== undefined)
                type = 1;

            if (type === 2) {
                nodes.push({ group: 'nodes', data: { id: id, displayName: track.name, name: id, track: id, lengths: track.lengths, connections: { a: a, b: b, c: c }, direction: 1, type: "turnout", relativePosition: { x: 0, y: 0 } }, position: { x: xPos, y: 0 }, classes: "trackNode turnout" });
                nodes.push({ group: 'nodes', data: { id: id + "_a", name: id + "_a", track: id, relativePosition: { x: -20, y: 0 } }, position: { x: xPos - 20, y: 0 }, classes: "turnoutConnection connection a" });
                nodes.push({ group: 'nodes', data: { id: id + "_b", name: id + "_b", track: id, relativePosition: { x: 20, y: 0 } }, position: { x: xPos + 20, y: -20 }, classes: "turnoutConnection connection b" });
                nodes.push({ group: 'nodes', data: { id: id + "_c", name: id + "_c", track: id, relativePosition: { x: 20, y: 20 } }, position: { x: xPos + 20, y: 20 }, classes: "turnoutConnection connection c" });

                edges.push({ group: 'edges', data: { source: id, target: id + "_a", track: id, connection: "a" }, classes: "track" });
                edges.push({ group: 'edges', data: { source: id, target: id + "_b", track: id, connection: "b" }, classes: "internal" });
                edges.push({ group: 'edges', data: { source: id, target: id + "_c", track: id, connection: "c" }, classes: "internal" });
            }
            else if (type === 1) {
                nodes.push({ group: 'nodes', data: { id: id, displayName: track.name, name: id, track: id, length: track.length, connections: { a: a, b: b, c: c }, type: "rail", relativePosition: { x: 0, y: 0 } }, position: { x: xPos, y: 0 }, classes: "trackNode rail" });
                nodes.push({ group: 'nodes', data: { id: id + "_a", name: id + "_a", track: id, relativePosition: { x: -20, y: 0 } }, position: { x: xPos - 20, y: 0 }, classes: "railConnection connection a" });
                nodes.push({ group: 'nodes', data: { id: id + "_b", name: id + "_b", track: id, relativePosition: { x: 20, y: 0 } }, position: { x: xPos + 20, y: 0 }, classes: "railConnection connection b" });

                edges.push({ group: 'edges', data: { source: id, target: id + "_a", track: id, connection: "a" }, classes: "track" });
                edges.push({ group: 'edges', data: { source: id, target: id + "_b", track: id, connection: "b" }, classes: "track" });
            }
            else {
                nodes.push({ group: 'nodes', data: { id: id, displayName: track.name, name: id, track: id, length: track.length, connections: { a: a, b: b, c: c }, type: "bumper", relativePosition: { x: 0, y: 0 } }, position: { x: xPos, y: 0 }, classes: "trackNode bumper" });
                nodes.push({ group: 'nodes', data: { id: id + "_a", name: id + "_a", track: id, relativePosition: { x: -20, y: 0 } }, position: { x: xPos - 20, y: 0 }, classes: "bumperConnection connection a" });
                edges.push({ group: 'edges', data: { source: id, target: id + "_a", track: id, connection: "a" }, classes: "track" });
            }

            console.log("added track " + id);

            if (a !== undefined) connect(id, a, "a");
            if (b !== undefined) connect(id, b, "b");
            if (c !== undefined) connect(id, c, "c");
        }

        let railwayString = "";
        let railwayStringSizeReceived = 0;
        function buildRailwayGraph(dataMsg) {
            let offset = dataMsg.offset;
            let fullSize = dataMsg.fullSize;
            let partialRailway = dataMsg.railway;

            railwayStringSizeReceived += partialRailway.length;

            if (railwayString.length < fullSize)
                railwayString = new Array(fullSize + 1).join(" ");

            railwayString = [railwayString.slice(0, offset), partialRailway, railwayString.slice(offset + partialRailway.length)].join('');

            if (railwayStringSizeReceived === fullSize) {

                let data = JSON.parse(railwayString);

                function classFromType(type) {
                    switch (type) {
                        case 0: return "bumper";
                        case 1: return "rail";
                        case 2: return "turnout";
                    }
                }

                let nodes = [];
                let edges = [];
                railway = data.tracks;
                signals = data.signals;
                blocks = data.blocks;
                detectors = data.detectors;

                _.each(data.tracks, function (track, i) {
                    addTrackToLayout(edges, nodes, data.tracks, track, i * 100);
                });

                cy = cytoscapeCreate();
                cy.add(nodes);
                cy.add(edges);
                cy = cytoscapeUpdateSignals(cy, data.signals);
                cy = cytoscapeUpdateBlocks(cy, data.blocks);
                cy = cytoscapeUpdateDetectors(cy, data.detectors);
                cy = cytoscapePostAdd(cy);

                if (allowLayoutLoading)
                    send("getRailwayLayout", {});
                else
                    allowLayoutLoading = true;
            }
        }

        function error(data) {
            $("#error").append($("<p>").html(data));
            console.error(data);
        }

        function message(data) {
            $("#message").append($("<p>").html(data));
            console.log(data);
        }

        function parse(content) {
            let op = content.op;
            let data = content.data;

            switch (op) {
                case "turnoutState": { turnoutState(data); break; }
                case "signalState": { signalState(data); break; }
                case "railway": { buildRailwayGraph(data); break; }
                case "layout": { updateRailwayLayout(data); break; }
                case "loco": { loco(data); break; }
                case "storeRailwayLayoutSuccessful": {
                    allowLayoutStorage = data;
                    if (allowLayoutStorage)
                        $saveLayout.removeClass("disabled");
                    message("layout storage successful: " + data); break;
                }
                case "locoPositions": { locoPositions(data); break; }
                case "error": { error(data); break; }
                default:
                    {
                        error("unparsable op:" + op);
                        break;
                    }
            }
        }

        function send(op, data) {
            if (socketState === SocketOpen)
                socket.send(JSON.stringify({ op: op, data: data }));
            else
                setTimeout(send, 100, op, data);
        }

        function cySplitEdge(event) {
            if (!cy || !allowLayoutEdit())
                return;

            cy.$('edge:selected').each(function (edge) {
                let nodes = edge.connectedNodes();
                let id = nodes[0].id() + "|" + nodes[1].id();
                let nodePosition = { x: (nodes[0].position().x + nodes[1].position().x) / 2.0, y: (nodes[0].position().y + nodes[1].position().y) / 2.0 };
                let parentTrack = nodes[0].data("track");
                let parentTrackNode = cy.$("#" + parentTrack);
                cy.add([
                    {
                        group: 'nodes', data: {
                            id: id,
                            track: nodes[0].data("track"),
                            relativePosition: { x: nodePosition.x - parentTrackNode.position().x, y: nodePosition.y - parentTrackNode.position().y }
                        },
                        position: nodePosition,
                        classes: "trackSplitNode"
                    },
                    { group: 'edges', data: { id: nodes[0].id() + "-" + id, track: nodes[0].data("track"), source: nodes[0].id(), target: id }, classes: "track" },
                    { group: 'edges', data: { id: id + "-" + nodes[1].id(), track: nodes[1].data("track"), source: id, target: nodes[1].id() }, classes: "track" }
                ]);
                edge.remove();
            });
            hideContextMenus();
        }

        function cyDeleteTrackNode(event) {
            if (!cy || !allowLayoutEdit())
                return;

            cy.$('node.trackSplitNode:selected').each(function (node) {
                let edges = node.connectedEdges();
                let neighbors = node.neighborhood("node");
                let id = neighbors[0].id() + "-" + neighbors[1].id();

                cy.add({ group: "edges", data: { id: id, source: neighbors[0].id(), target: neighbors[1].id() }, classes: "track" });

                edges.edges();
                node.remove();
            });
            hideContextMenus();
        }

        function cyPullNode(event) {
            if (!cy || !allowLayoutEdit())
                return;

            cy.$('node:selected').each(function (node) {
                let edges = node.connectedEdges();

                if (node.hasClass("connector")) {
                    let neighbor = node.openNeighborhood("node.connection");
                    neighbor.each((neigh, i) => {
                        let track = neigh.data("track");
                        cy.$('node.trackNode[track="' + track + '"]').each(function (n) {
                            let distance = Math.sqrt((neigh.position().x - node.position().x) * (neigh.position().x - node.position().x) + (neigh.position().y - node.position().y) * (neigh.position().y - node.position().y));
                            if (distance > 100)
                                n.position({ x: node.position().x + 40 * (i * 2 - 1), y: node.position().y }).emit("position");
                        });
                    });
                }
                else // connection
                {
                    let neighbor = node.openNeighborhood("node.connector");
                    let distance = Math.sqrt((neighbor.position().x - node.position().x) * (neighbor.position().x - node.position().x) + (neighbor.position().y - node.position().y) * (neighbor.position().y - node.position().y));
                    if (distance > 100)
                        neighbor.position({ x: node.position().x + 40, y: node.position().y }).emit("position");
                }
                    /*
                let neighbor = node.openNeighborhood(node.hasClass("connector") ? "node.connection" : "node.connector");
                let track = neighbor.data("track");

                cy.$('node.trackNode[track="' + track + '"]').each(function (n) {
                    n.position({ x: node.position().x + 40, y: node.position().y }).emit("position");
                });*/
            });
            hideContextMenus();
        }

        $(function () {
            let URLsp = new URLSearchParams(window.location.search);
            $("#ip").on('change', () => {
                putStateIntoURL();
            }).val(URLsp.get('ipport') || "127.0.0.1:8080");
            connect();

            $railway = $("#railway");
            $("#splitEdge").on('click', cySplitEdge);
            $("#deleteTrackNode").on('click', cyDeleteTrackNode);
            $("#pullConnectedNode").on('click', cyPullNode);
            $(".cancel").on('click', function (event) {
                $(".contextMenu").hide();
                cy.$().unselect();
            });
            $("#settingsToggle").on('click', function () { $("#settingsContent").toggle(); });
            hideContextMenus();
            $("#settingsContent").hide();

            $saveLayout = $("#saveLayout");
            $saveLayout.on('click', function () {
                if (allowLayoutStorage === true) {
                    allowLayoutStorage = false;
                    $saveLayout.addClass("disabled");
                    storeRailwayLayout();
                }
            });
            $saveLayout.addClass("disabled");

            $resetLayout = $("#resetLayout");
            $resetLayout.on('click', function () {
                allowLayoutLoading = false;
                send("getRailway", {});
            });
            $resetLayout.addClass("disabled");

            $("#layoutEdit").on('change', function (event) {
                uiEditLayout = $(event.target).prop("checked");
                if (!allowLayoutEdit()) {
                    cy.nodes().ungrabify();
                    $saveLayout.addClass("disabled");
                    $resetLayout.addClass("disabled");
                }
                else {
                    cy.nodes().grabify();
                    if (allowLayoutStorage === true) {
                        $saveLayout.removeClass("disabled");
                        $resetLayout.removeClass("disabled");
                    }
                }
                putStateIntoURL();
            });
            $("#blockView").on('change', function (event) {
                if ($(event.target).prop("checked"))
                    cy.$("[blockColor]").addClass("blockColoring");
                else
                    cy.$().removeClass("blockColoring");
                putStateIntoURL();
            });
            $("#detectorDebug").on('change', (event) => {
                if ($(event.target).prop("checked"))
                    cy.$(".detector").style("display", "element");
                else
                    cy.$(".detector").style("display", "none");
                putStateIntoURL();
            });

            $("#reconnect").on('click', function () {
                connect();
                send("getRailway", {});
                send("getLocoShed", {});
            });

            //$('#sideLoco').sideNav({edge: "left", isFixed: true});

            M.Sidenav.init($('#sideLoco').get(0), { edge: "right" }).open();
            M.Sidenav.init($('#sideTurnout').get(0), { edge: "left" }).open();

            M.AutoInit();
            //$('select').material_select();
            M.FormSelect.init(document.querySelectorAll('select'));

            //$("#sideLoco").get(0).sidenav();

            send("getRailway", {});
            send("getLocoShed", {});
        });

        function putStateIntoURL() {
            var url = window.location.protocol + "//" + window.location.host + window.location.pathname + '?';
            url += "ipport=" + $("#ip").val();
            if ($("#gridView").prop("checked"))
                url += "&gridView";
            if ($("#layoutEdit").prop("checked"))
                url += "&layoutEdit";
            if ($("#blockView").prop("checked"))
                url += "&blockView";
            if ($("#detectorDebug").prop("checked"))
                url += "&detectorDebug";
            window.history.pushState({ path: url }, '', url);
        }

    </script>
    <script type="text/javascript" src="materialize.min.js"></script>
    <script type="text/javascript" src="cytoscape.min.js"></script>
    <script type="text/javascript" src="cytoscape-grid-guide.js"></script>
    <script type="text/javascript" src="cytoscape-node-html-label.min.js"></script>
</body>

</html>